=====================================
Writing your first Django app, part 5
=====================================

This tutorial begins where :doc:`Tutorial 4 </intro/tutorial04>` left off.
We've built a Web-poll application and we'll now create some automated tests
for it.

Introducing automated testing
=============================

What are automated tests?
-------------------------

Tests are simple routines that check the operation of your code. 

Testing operates at different levels. Some tests might apply to a tiny detail
- does a particular model method return values as expected? - or to the
overall operation of the software - does a sequence of user inputs on the site
produce the desired result?

That's no different from the kind of testing you will have done already: using
the shell as in :doc:`Tutorial 1 </intro/tutorial01>` to examine the behaviour
of a method, or running the application and entering data to check how it
behaves.

What's different in *automated* tests is that the testing work is done for
you, by the system. You create a test, once, and from then on you can rely on
Django to prove for evermore that the code still works, and alert you when a
change you made means it doesn't any longer.

Why you need to create tests
----------------------------

So why create tests, and why now?

You may feel you have quite enough on your plate just learning Python/Django,
and having yet another thing to learn, and do. After all, our Polls
application is working quite happily now; going to the trouble of creating
automated tests is not going to make it work any better.

The answer to that is: if creating the Polls application is the last bit of
Django programming you will ever do, then true, you don't need to know how to
create automated tests.

But, if that's not the case, now is an excellent time to learn.

Tests will save you time
~~~~~~~~~~~~~~~~~~~~~~~~

Speaking of time, that is exactly what automated tests will save you. Even
a simple application like Polls needs to be tested. 

Up to a certain point, 'checking that it seems to work' will be a satisfactory
test. In a more sophisticated application you might have dozens of complex
interactions between components. 

Any change, in any of those components, could have unexpected consquences on
the application's output. If checking that it still 'seems to work' means you
have to run through its functionality with twenty different variations of your
test data to see whether your most recent tweak to the code has broken
anything is not a good use of your time.

That's especially true when automated tests could do it for you in seconds,
and if something's going wrong, identify the exact place where it happens.

Sometimes it may seem a chore to tear yourself away from your productive
creative programming work to face the more unglamorous and unexciting business
of writing tests, particularly when you know your code is working properly.

However, even the unexciting task of writing tests is a lot more fulfilling
than spending hours testing your application manually, and even longer trying
to identify the cause of a newly-introduced problem.

Tests don't just identify problems, they prevent them
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

It's a mistake in fact to think of tests merely as a negative aspect of
development.

Without tests, even when it's working, an application might be rather opaque,
if not actually a black box. Even when it's your own code you will sometimes
find yourself poking around in it trying to find out what exactly it is doing.

Tests change that; they light up your code from the inside, and when something
goes wrong inside they focus the light on the part that has gone wrong - *even
if you hadn't even realised it had gone wrong*.

Your code needs tests to be considered respectable
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Finally, tests make your code respectable. You might have created a brilliant
piece of software, but you *will* find that many other developers simply
refuse to look at it because it lacks tests; without tests, they won't trust
it. 

So even if you're not persuaded by the arguments above, the fact that other
developers want to see tests in your software before they take it seriously
should be reason for you to start creating tests yourself.

* Jacob quote - code without tests is broken by design

Basic testing strategies
========================

There is not just one way of writing tests.

Some programmers follow a discipline called "test-driven development"; they
actually write their tests before they write their code. This might seem
counter-intuitive, but in fact it's similar to what most people do anyway:
they describe a problem, then create some code to solve it. Test-driven
development simply formalises the problem in a Python test case.

More typically, a newcomer to testing will have created some code, and later
decides that it should have had some tests. Perhaps it would have been better
to write some tests earlier on, but it's never to late to get started.

Sometimes it's hard to find a way in. If you have written several thousand
lines of Python, choosing something to test might not be easy.

In such a case, it's fruitful to write your first test the next time you make
a change, either when you add a new feature or fix a bug.

So let's do that right away. 

Writing our first test
======================

Fortunately, there is in fact a little bug in the ``polls`` application for us
to fix right away: the ``Poll.was_published_recently()`` method returns True if
the Poll was published in the last day (which is correct) but also if the
Poll's ``pub_date`` field is in the future (which certainly isn't).

You can see this in the Admin; create a Poll whose date lies in the future;
you'll see that the Poll change list claims it was published recently.

Edit the ``tests.py`` file in the ``polls`` application::

	# import the Django TestCase class
	from django.test import TestCase

	# import the Poll model we want to test
	from models import Poll

	# we're testing the behaviour of a method that uses date-related functions
	import datetime
	from django.utils import timezone

	# we'll put all the Poll method tests in a class together
	class PollMethodTests(TestCase):

	    def test_future_poll(self):
	        # create a Poll instance whose pub_date is in the future
	        future_poll = Poll(pub_date=timezone.now() + datetime.timedelta(days=30))
	        # was_published_recently() should return True
	        self.assertEqual(future_poll.was_published_recently(), False)

And in the terminal::

	python manage.py test polls
	
and you'll see something like::

	Creating test database for alias 'default'...
	F
	======================================================================
	FAIL: test_future_poll (polls.tests.PollMethodTests)
	----------------------------------------------------------------------
	Traceback (most recent call last):
	  File "/home/daniele/django-testing-tutorial/mysite/polls/tests.py", line 18, in test_future_poll
	    self.assertEqual(future_poll.was_published_recently(), False)
	AssertionError: True != False

	----------------------------------------------------------------------
	Ran 1 test in 0.000s

	FAILED (failures=1)
	Destroying test database for alias 'default'...

What happened is this:

* ``python manage.py test polls`` looked for tests in the ``polls`` application
          
* it found a sub-class of the TestCase class

* it created a special database just for the purpose of testing

* it looked for test methods - ones whose names begin with ``test``

* in ``test_future_poll`` it created a ``Poll`` instance whose ``pub_date`` field is
  in the future

* ... and using the ``assertEqual()`` method, discovered that its
  ``was_published_recently()`` returns True, though we wanted it to return False          

The test informs us which test failed - ``test_future_poll`` - and even the
line on which the failure occurred.

We already know what the problem is: ``Poll.was_published_recently()`` should
return False if its ``pub_date`` is in the future. So amend it, in ``models.py``::

    def was_published_recently(self):
        return self.pub_date >= timezone.now() - datetime.timedelta(days=1) and self.pub_date < timezone.now()

and running the test again::

	Creating test database for alias 'default'...
	.
	----------------------------------------------------------------------
	Ran 1 test in 0.000s

	OK
	Destroying test database for alias 'default'...

So now having identified a bug, we have written a test that exposes it, and
corrected the bug in the code. 

Many other things might go wrong with our application in the future, but we
can now be sure that we won't inadvertantly reintroduce this bug, because
simply running the test will warn us immediately. We can consider this little portion of the application pinned down safely forever.

While we're here, we can further pin down the ``was_published_recently()`` method; in fact, it would be embarassing if in fixing one bug we had introduced another.

Add two more test methods::

    def test_old_poll(self):
        # create a Poll instance whose pub_date is 30 days ago
        old_poll = Poll(pub_date=timezone.now() - datetime.timedelta(days=30))
        # was_published_recently() should return False
        self.assertEqual(old_poll.was_published_recently(), False)
    
    def test_recent_poll(self):
        # create a Poll instance whose pub_date is one hour ago
        recent_poll = Poll(pub_date=timezone.now() - datetime.timedelta(hours=1))
        # was_published_recently() should return True
        self.assertEqual(recent_poll.was_published_recently(), True)

And now we have three tests, that confirm that ``Poll.was_published_recently()``
returns sensible values for past, recent and future Polls.

Again, polls is a simple application, but however complex it grows in the
future, and whatever other code comes to interact with it, we now have some
guarantee that the method we have written tests for will behave in expected
ways.

Test a view
===========

* is_published field

Test the user experience
========================

* selenium




What's next?
============

The tutorial ends here for the time being. In the meantime, you might want to
check out some pointers on :doc:`where to go from here </intro/whatsnext>`.
                                                               