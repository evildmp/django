=====================================
Writing your first Django app, part 5
=====================================

This tutorial begins where :doc:`Tutorial 4 </intro/tutorial04>` left off.
We've built a Web-poll application and we'll now create some automated tests
for it.

Introducing automated testing
=============================

What are automated tests?
-------------------------

Tests are simple routines that check the operation of your code. 

Testing operates at different levels. Some tests might apply to a tiny detail
- does a particular model method return values as expected? - or to the
overall operation of the software - does a sequence of user inputs on the site
produce the desired result?

That's no different from the kind of testing you will have done already: using
the shell as in :doc:`Tutorial 1 </intro/tutorial01>` to examine the behaviour
of a method, or running the application and entering data to check how it
behaves.

What's different in *automated* tests is that the testing work is done for
you, by the system. You create a test, once, and from then on you can rely on
Django to prove for evermore that the code still works, and alert you when a
change you made means it doesn't any longer.

Why you need to create tests
----------------------------

So why create tests, and why now?

You may feel you have quite enough on your plate just learning Python/Django,
and having yet another thing to learn, and do. After all, our Polls
application is working quite happily now; going to the trouble of creating
automated tests is not going to make it work any better.

The answer to that is: if creating the Polls application is the last bit of
Django programming you will ever do, then true, you don't need to know how to
create automated tests.

But, if that's not the case, now is an excellent time to learn.

Tests will save you time
~~~~~~~~~~~~~~~~~~~~~~~~

Speaking of time, that is exactly what automated tests will save you. Even
a simple application like Polls needs to be tested. 

Up to a certain point, 'checking that it seems to work' will be a satisfactory
test. In a more sophisticated application you might have dozens of complex
interactions between components. 

Any change, in any of those components, could have unexpected consquences on
the application's output. If checking that it still 'seems to work' means you
have to run through its functionality with twenty different variations of your
test data to see whether your most recent tweak to the code has broken
anything is not a good use of your time.

That's especially true when automated tests could do it for you in seconds,
and if something's going wrong, identify the exact place where it happens.

Sometimes it may seem a chore to tear yourself away from your productive
creative programming work to face the more unglamorous and unexciting business
of writing tests, particularly when you know your code is working properly.

However, even the unexciting task of writing tests is a lot more fulfilling
than spending hours testing your application manually, and even longer trying
to identify the cause of a newly-introduced problem.

Tests don't just identify problems, they prevent them
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

It's a mistake in fact to think of tests merely as a negative aspect of
development.

Without tests, even when it's working, an application might be rather opaque,
if not actually a black box. Even when it's your own code you will sometimes
find yourself poking around in it trying to find out what exactly it is doing.

Tests change that; they light up your code from the inside, and when something
goes wrong inside they focus the light on the part that has gone wrong - *even
if you hadn't even realised it had gone wrong*.

Your code needs tests to be considered respectable
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Finally, tests make your code respectable. You might have created a brilliant
piece of software, but you *will* find that many other developers simply
refuse to look at it because it lacks tests; without tests, they won't trust
it. 

So even if you're not persuaded by the arguments above, the fact that other
developers want to see tests in your software before they take it seriously
should be reason for you to start creating tests yourself.

* Jacob quote - code without tests is broken by design

Basic testing strategies
========================

There is not just one way of writing tests.

Some programmers follow a discipline called "test-driven development"; they
actually write their tests before they write their code. This might seem
counter-intuitive, but in fact it's similar to what most people do anyway:
they describe a problem, then create some code to solve it. Test-driven
development simply formalises the problem in a Python test case.

More typically, a newcomer to testing will have created some code, and later
decides that it should have had some tests. Perhaps it would have been better
to write some tests earlier on, but it's never to late to get started.

Sometimes it's hard to find a way in. If you have written several thousand
lines of Python, choosing something to test might not be easy.

In such a case, it's fruitful to write your first test the next time you make
a change, either when you add a new feature or fix a bug.

So let's do that right away. 

Writing our first test
======================

We identify a bug
-----------------

Fortunately, there is in fact a little bug in the ``polls`` application for us
to fix right away: the ``Poll.was_published_recently()`` method returns True if
the Poll was published in the last day (which is correct) but also if the
Poll's ``pub_date`` field is in the future (which certainly isn't).

You can see this in the Admin; create a Poll whose date lies in the future;
you'll see that the Poll change list claims it was published recently.

Since things in the future are not 'recent', this is clearly wrong.

You can also see this using the shell::

    >>> # import the things we need
    >>> from polls.models import Poll
    >>> import datetime
    >>> from django.utils import timezone
    >>> # create a Poll instance with pub_date 30 days in the future
    >>> future_poll = Poll(pub_date=timezone.now() + datetime.timedelta(days=30))
    >>> # was it published recently?
    >>> future_poll.was_published_recently()
    True

Create a test to expose the bug
-------------------------------

What we've just done in the shell to test it is exactly what we can do in an
automated test, so let's turn that into an automated test.

The best place for an application's tests is in the application's ``tests.py``
file - the testing system will look there for tests automatically.

Edit the ``tests.py`` file in the ``polls`` application::

	# import the Django TestCase class
	from django.test import TestCase

	# import the Poll model we want to test
	from models import Poll

	# we're testing the behaviour of a method that uses date-related functions
	import datetime
	from django.utils import timezone

	# we'll put all the Poll method tests in a class together
	class PollMethodTests(TestCase):

	    # was_published_recently() should report False for items in the future
	    def test_future_poll(self):
	        # create a Poll instance whose pub_date is in the future
	        future_poll = Poll(pub_date=timezone.now() + datetime.timedelta(days=30))
	        # was_published_recently() should return True
	        self.assertEqual(future_poll.was_published_recently(), False)

What we have done here is created a ``TestCase`` subclass, with a method that
creates an instance of ``Poll`` with a date in the future, and then checks the
output of ``was_published_recently()`` - which *ought* to be False.

Running tests
-------------

And in the terminal, we can run our test::

	python manage.py test polls
	
and you'll see something like::

	Creating test database for alias 'default'...
	F
	======================================================================
	FAIL: test_future_poll (polls.tests.PollMethodTests)
	----------------------------------------------------------------------
	Traceback (most recent call last):
	  File "/home/daniele/django-testing-tutorial/mysite/polls/tests.py", line 18, in test_future_poll
	    self.assertEqual(future_poll.was_published_recently(), False)
	AssertionError: True != False

	----------------------------------------------------------------------
	Ran 1 test in 0.000s

	FAILED (failures=1)
	Destroying test database for alias 'default'...

What happened is this:

* ``python manage.py test polls`` looked for tests in the ``polls`` application
          
* it found a sub-class of the TestCase class

* it created a special database just for the purpose of testing

* it looked for test methods - ones whose names begin with ``test``

* in ``test_future_poll`` it created a ``Poll`` instance whose ``pub_date``
  field is in the future

* ... and using the ``assertEqual()`` method, discovered that its
  ``was_published_recently()`` returns True, though we wanted it to return False          

The test informs us which test failed - ``test_future_poll`` - and even the
line on which the failure occurred.

Fixing the bug
--------------

We already know what the problem is: ``Poll.was_published_recently()`` should
return False if its ``pub_date`` is in the future. So amend it, in
``models.py``, so that it will only return True if the date is also in the
past::

    def was_published_recently(self):
        return self.pub_date >= timezone.now() - datetime.timedelta(days=1) and self.pub_date < timezone.now()

and running the test again::

	Creating test database for alias 'default'...
	.
	----------------------------------------------------------------------
	Ran 1 test in 0.000s

	OK
	Destroying test database for alias 'default'...

So now having identified a bug, we have written a test that exposes it, and
corrected the bug in the code. 

Many other things might go wrong with our application in the future, but we can
now be sure that we won't inadvertantly reintroduce this bug, because simply
running the test will warn us immediately. We can consider this little portion
of the application pinned down safely forever.

More comprehensive tests
------------------------

While we're here, we can further pin down the ``was_published_recently()``
method; in fact, it would be embarassing if in fixing one bug we had introduced
another.

Add two more test methods, to test the behaviour of the method more
comprehensively::

    # was_published_recently() should report False for older items
    def test_old_poll(self):
        # create a Poll instance whose pub_date is 30 days ago
        old_poll = Poll(pub_date=timezone.now() - datetime.timedelta(days=30))
        # was_published_recently() should return False
        self.assertEqual(old_poll.was_published_recently(), False)
    
    # was_published_recently() should report True for older < 24 hours old
    def test_recent_poll(self):
        # create a Poll instance whose pub_date is one hour ago
        recent_poll = Poll(pub_date=timezone.now() - datetime.timedelta(hours=1))
        # was_published_recently() should return True
        self.assertEqual(recent_poll.was_published_recently(), True)

And now we have three tests, that confirm that ``Poll.was_published_recently()``
returns sensible values for past, recent and future Polls.

Again, polls is a simple application, but however complex it grows in the
future, and whatever other code comes to interact with it, we now have some
guarantee that the method we have written tests for will behave in expected
ways.

Test a view
===========

The polls application is fairly undiscriminating: it will publish any Poll,
including:

* ones whose ``pub_date`` field lies in the future
* ones without any choices

We should improve this. Setting a ``pub_date`` in the future should mean that
the Poll is published at that moment, but invisible until then. And a Poll
without at least two choices is clearly not ready to be published.

We'll begin by tackling the date-related publishing improvement.

A test for a view
-----------------

When we fixed the bug above we wrote the test first, and then the code to fix
it. In fact that was a simple example of *test-driven development*, but it
doesn't really matter in which order we do the work.

In our first test, we focused closely on the internal behaviour of the code. For
this test, we want to check its behaviour as it would be experienced by a user.

Before we try to fix anything, let's have a look at the tools at our disposal.

The Django test client
----------------------

Django provides a test ``Client`` to simulate and test a user's interacting with
the code at the view level. Try this in the shell::

    >>> # import the test Client class
    >>> from django.test.client import Client
    >>> # create an instance of it for our use
    >>> c = Client()
    >>> # get a response from '/'
    >>> response = c.get('/')
    >>> #  we should expect a 404 from that address
    >>> response.status_code
    404
    >>> # but we should expect to find something at '/polls/'
    >>> # we'll this is with 'reverse()' rather than a harcoded URL
    >>> from django.core.urlresolvers import reverse
    >>> response = c.get(reverse('polls:index'))
    >>> response.status_code
    200
    >>> response.content
    '\n\n\n    <p>No polls are available.</p>\n\n'
    >>> # note - you might get unexpected results if your ``TIME_ZONE`` 
    >>> # in ``settings.py`` is not correct. If you need to change it,
    >>> # you will also need to restart your shell session
    >>> from polls.models import Poll
    >>> from django.utils import timezone
    >>> # create a Poll and save it 
    >>> p = Poll(question="Who is your favourite Beatle?", pub_date=timezone.now())
    >>> p.save()
    >>> # check the response once again
    >>> response = c.get('/polls/')
    >>> response.content
    '\n\n\n    <ul>\n    \n        <li><a href="/polls/1/">Who is your favourite Beatle?</a></li>\n    \n    </ul>\n\n'
    # note - I don't understand why response.context_data is required here instead of response.context:
    >>> response.context_data['latest_poll_list']
    [<Poll: Who is your favourite Beatle?>]

Improving our view
------------------

In :doc:`Tutorial 4 </intro/tutorial04>` we deleted the view functions from
``views.py``, to use a ListView doc:`generic
view</topics/class-based-views/index>` in ``urls.py``::

    url(r'^$',
        ListView.as_view(
            queryset=Poll.objects.order_by('-pub_date')[:5],
            context_object_name='latest_poll_list',
            template_name='polls/index.html'),
        name='index'),

``response.context_data['latest_poll_list']`` extracts the data this view placed
into the context.

What we need to amend is the line that gives our ``queryset``::

    queryset=Poll.objects.order_by('-pub_date')[:5],
    
and what we need to do is change that so that it also checks the date,
comparing it with ``timezone.now()``. So, first we need::

    from django.utils import timezone

and then we must amend the url function::

    url(r'^$',
        ListView.as_view(
            queryset=Poll.objects.filterorder_by('-pub_date')[:5],
            context_object_name='latest_poll_list',
            template_name='polls/index.html'),
        name='index'),

to::

    urlpatterns = patterns('',
        url(r'^$',
            ListView.as_view(
                queryset=Poll.objects.filter(pub_date__lte=timezone.now()).order_by('-pub_date')[:5],
                context_object_name='latest_poll_list',
                template_name='polls/index.html'),
            name='index'),

``Poll.objects.filter(pub_date__lte=timezone.now())`` returns a queryset
containing Polls whose pub_date is less than or equal to - that is, earlier than
or equal to - ``timezone.now()``.

Testing our new view
--------------------

Now you can satisfy yourself that this behaves as expected by firing up the
runserver, loading the site in your browser, creating Polls with dates in the
past and future, and checking that only the right ones are listed - but you
don't want to have to do that *every single time you change that might affect
this* - so let's also create a test, based on our shell session above.

To ``tests.py`` add::

    # we need the test client for views
    from django.test.client import Client
    
    # to work out URLs from the view we need urlresolvers.reverse
    from django.core.urlresolvers import reverse

and we'll create a new class too::

    # we'll put all the view tests in a class together
    class PollViewTests(TestCase):
        # setUp will set up our testing environment for each test
        def setUp(self):
            # Every test needs a client.
            self.client = Client()

        def test_index_view_no_polls(self):
            # Issue a GET request.
            response = self.client.get(reverse('polls:index'))

            # we should get a 200 OK
            self.assertEqual(response.status_code, 200)          

            # there should be nothing in the latest_poll_list
            self.assertEqual(len(response.context_data['latest_poll_list']), 0)          

        def test_index_view_with_polls(self):
            # create a Poll instance whose pub_date is 30 days ago
            beatles_poll = Poll(
                question="Who is your favourite Beatle?", 
                pub_date=timezone.now() - datetime.timedelta(days=30)
                )
            beatles_poll.save()
            response = self.client.get(reverse('polls:index'))
            # the only item in the list should be beatles_poll
            self.assertEqual(len(response.context_data['latest_poll_list']), 1)          
            self.assertEqual(response.context_data['latest_poll_list'][0], beatles_poll)          

            # create a Poll instance whose pub_date is 30 in the future
            stones_poll = Poll(
                question="Who is your favourite Rolling Stone?", 
                pub_date=timezone.now() + datetime.timedelta(days=30)
                )
            stones_poll.save()
            response = self.client.get(reverse('polls:index'))
            # the only item in the list should *still* be beatles_poll
            self.assertEqual(len(response.context_data['latest_poll_list']), 1)          
            self.assertEqual(response.context_data['latest_poll_list'][0], beatles_poll)          

            # change the date on the stones_poll - put it in the past
            stones_poll.pub_date = timezone.now() - datetime.timedelta(days=5)
            stones_poll.save()
            response = self.client.get(reverse('polls:index'))
            # we should 2 items now, stones_poll first and beatles_poll second
            self.assertEqual(len(response.context_data['latest_poll_list']), 2)          
            self.assertEqual(response.context_data['latest_poll_list'][0], stones_poll)          
            self.assertEqual(response.context_data['latest_poll_list'][1], beatles_poll)          

In effect, we are now using the tests to tell a story of admin input and user
experience on the site, and checking that at every state and for every new
change in the state of the system, the expected results are published.

As the system becomes more complex, we can add more tests, but the basic
principle is the same.

Test the user experience 
========================

* selenium


What's next?
============

The tutorial ends here for the time being. In the meantime, you might want to
check out some pointers on :doc:`where to go from here </intro/whatsnext>`.
                                                               